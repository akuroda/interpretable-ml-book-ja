```{r, message = FALSE, warning = FALSE, echo = FALSE}
devtools::load_all()
set.seed(42)
```

<!--{pagebreak}-->

## Permutation Feature Importance {#feature-importance}
<!--## Permutation Feature Importance {#feature-importance}-->

<!--
Permutation feature importance measures the increase in the prediction error of the model after we permuted the feature's values, which breaks the relationship between the feature and the true outcome. 
-->
Permutation feature importance は、特徴量の値を並び替えることで、特徴量と真の結果との関係性を壊し、これによる予測誤差の増加を測定します。

<!--### Theory-->
### 理論

<!--
The concept is really straightforward: 
We measure the importance of a feature by calculating the increase in the model's prediction error after permuting the feature.
A feature is "important" if shuffling its values increases the model error, because in this case the model relied on the feature for the prediction.
A feature is "unimportant" if shuffling its values leaves the model error unchanged, because in this case the model ignored the feature for the prediction.
The permutation feature importance measurement was introduced by Breiman (2001)[^Breiman2001] for random forests.
Based on this idea, Fisher, Rudin, and Dominici (2018)[^Fisher2018] proposed a model-agnostic version of the feature importance and called it model reliance. 
They also introduced more advanced ideas about feature importance, for example a (model-specific) version that takes into account that many prediction models may predict the data well.
Their paper is worth reading.
-->
概念はとても単純です。
特徴量を並び替えたあとのモデルの予測誤差の影響を計算することで、特徴量の重要度を計算します。
特徴量の値を入れ替えるとモデル誤差が増加する場合、モデルは特徴量に依存した予測をしているので、その特徴量は「重要」です。
特徴量の値を入れ替えてもモデル誤差が変わらない場合、特徴量は「重要ではない」と言えます。
permutation feature importance は、Breiman (2001)[^Breiman2001]によってランダムフォレストのために導入されました。
この考えに基づいて、Fisher, Rudin, Dominici (2018)[^Fisher2018]は、モデルに依存しない特徴量重要度を提案し、これをモデル信頼度と呼んでいます。
彼らは、それに加えて特徴量の重要度に関する、より高度な考え方、例えば、多くの予測モデルがデータをうまく予測する可能性があることを考慮した（モデル固有の）バージョンも紹介しています。
彼らの論文 **The permutation feature importance algorithm based on Fisher, Rudin, and Dominici (2018)** は一読の価値があります。


<!--Input: Trained model f, feature matrix X, target vector y, error measure L(y,f).-->
入力: 学習モデル f, 特徴量行列 X, 目標ベクトル y, 誤差関数 L(y,f)

<!--
1. Estimate the original model error e^orig^ = L(y, f(X))  (e.g. mean squared error)
2. For each feature j = 1,...,p do:
    - Generate feature matrix X^perm^ by permuting feature j in the data X. This breaks the association between feature j and true outcome y.
    - Estimate error e^perm^ = L(Y,f(X^perm^)) based on the predictions of the permuted data.
    - Calculate permutation feature importance FI^j^= e^perm^/e^orig^. Alternatively, the difference can be used: FI^j^ = e^perm^ - e^orig^
3. Sort features by descending FI.
-->
1. 元のモデル誤差 e^orig^ = L(y, f(X)) を推定します。（例: 平均二乗誤差）
2. 各特徴量 j = 1,....,p について
    - データ X の特徴量 j を並べ替えて特徴量行列 X^perm^ を生成します。これにより、特徴量 j と真の結果 y との間の関連付けが解除されます。
    - 並べ替えられたデータの予測値に基づいて、誤差 e^perm^ = L(Y,f(X^perm^)) を推定します。
    - 並べ替えた特徴量の重要度 FI^j^= e^perm^/e^orig^ を計算します。あるいは、差分 FI^j^ = e^perm^ - e^orig^ も使用できます。
3. FIが高い順に特徴量をソートします。

<!--
Fisher, Rudin, and Dominici (2018) suggest in their paper to split the dataset in half and swap the values of feature j of the two halves instead of permuting feature j. 
This is exactly the same as permuting feature j, if you think about it. 
If you want a more accurate estimate, you can estimate the error of permuting feature j by pairing each instance with the value of feature j of each other instance (except with itself). 
This gives you a dataset of size `n(n-1)` to estimate the permutation error, and it takes a large amount of computation time. 
I can only recommend using the `n(n-1)` -method if you are serious about getting extremely accurate estimates.
-->
Fisher, Rudin, Dominici (2018)の論文では、特徴量 j を並べ替える代わりに、データセットを半分に分割し、それらの間で特徴量 j の値を入れ替えることを提案しています。
これは考えてみれば、特徴量 j を並べ替えるのと全く同じです。
より正確な推定をしたい場合は、各インスタンスを他のインスタンスの特徴量 j の値とペアにすることで、特徴量 j の並べ替えの誤差を推定できます（自分自身とのペアを除く）。
これにより、並べ替え誤差を推定するための`n(n-1)`のサイズのデータセットが得られますが、膨大な計算時間がかかります。
厳密な推定値を得ることを真剣に考えている場合にのみ、この方法を使うことをお勧めします。

<!--### Should I Compute Importance on Training or Test Data? {#feature-importance-data}-->
### 特徴量の重要度は、学習データとテストデータのどちらで計算するべきか {#feature-importance-data}

```{r prepare-garbage-svm}
set.seed(1)
n = 200
p = 50
X = data.frame(matrix(rnorm(n*p), nrow = n))
y = rnorm(n)
dat = cbind(X, y)
tsk = makeRegrTask(data = dat, target = "y")

X2 = data.frame(matrix(rnorm(n*p), nrow = n))
y2 = rnorm(n)
dat2 = cbind(X2, y = y2)
tsk2 = makeRegrTask(data = dat2, target = "y")

lrn = makeLearner("regr.svm")
mod = mlr::train(lrn, tsk)
pred = predict(mod, tsk)
perf1 = mlr::performance(pred, measures = list(mlr::mae))

pred2 = predict(mod, tsk2)
perf2 = mlr::performance(pred2, measures = list(mlr::mae))

```

<!--*tl;dr: I do not have a definite answer.*-->

*tl;dr: 明確な答えはありません。*  

<!--
Answering the question about training or test data touches the fundamental question of what feature importance is.
The best way to understand the difference between feature importance based on training vs. based on test data is an "extreme" example.
I trained a support vector machine to predict a continuous, random target outcome given 50 random features (200 instances).
By "random" I mean that the target outcome is independent of the 50 features.
This is like predicting tomorrow's temperature given the latest lottery numbers.
If the model "learns" any relationships, then it overfits.
And in fact, the SVM did overfit on the training data.
The mean absolute error (short: mae) for the training data is `r round(perf1,2)` and for the test data `r round(perf2,2)`, which is also the error of the best possible model that always predicts the mean outcome of 0 (mae of  `r round(mean(abs(y2)),2)`).
In other words, the SVM model is garbage.
What values for the feature importance would you expect for the 50 features of this overfitted SVM?
Zero because none of the features contribute to improved performance on unseen test data?
Or should the importances reflect how much the model depends on each of the features, regardless whether the learned relationships generalize to unseen data?
Let us take a look at how the distributions of feature importances for training and test data differ.
-->
学習データかテストデータかの疑問に答えることは、特徴量重要度とは何かという根本的な問題に首を突っ込むことになります。
学習データとテストデータに基づいた特徴量重要度の違いを理解するためには、「極端な」例が一番適しています。
50個のランダムな特徴量（200のインスタンス）に基づいて、連続でランダムなターゲットを予測するサポートベクタマシンを学習しました。
「ランダム」というのは、ターゲットが 50 個の特徴量とは独立であることを意味しています。
これは最新の宝くじの番号から明日の気温を予測するようなものです。
もしモデルが何かの関係性を「学習した」のならば、それは過学習だといえます。
そして実際、SVMは学習データに過学習してしまいました。
平均絶対誤差 (MAE) は学習データにおいて `r round(perf1,2)` 、テストデータにおいて `r round(perf2,2)` であり、これは常に平均値が0 (MAEは `r round(mean(abs(y2)),2)` ) となる結果を予測するような最良のモデルの誤差でもあります。
言い換えれば、このSVMモデルは何の役にも立たないということです。
この過学習したSVMの50個の特徴量の重要度にどんな値が期待できるでしょうか。
まだ見ぬテストデータのパフォーマンスを向上させるような特徴量がないことから 0 となるのでしょうか。
もしくは、学習された関係性がまだ見ぬデータに一般化されているかどうかにかかわらず、重要度はモデルがどれだけそれぞれの特徴量に依存しているかを反映するのでしょうか。
学習データとテストデータの特徴量重要度の分布がどのように異なるのか見ていきましょう。

<!--
fig.cap="Distributions of feature importance values by data type. An SVM was trained on a regression dataset with 50 random features and 200 instances. The SVM overfits the data: Feature importance based on the training data shows many important features. Computed on unseen test data, the feature importances are close to a ratio of one (=unimportant)."
-->
```{r feature-imp-sim, fig.cap="データのタイプによる特徴量重要度の分布。SVM は 50 個のランダムな特徴量を持つ 200 のインスタンスからなる回帰データセットで学習された。SVM は過学習しており、学習データに対する特徴量重要度では重要な特徴量がいくつか示されている。一方で、まだ見ぬテストデータに関して計算したところ、特徴量重要度は比率が 1 に近い値（＝重要ではない）となった。"}
pred = Predictor$new(mod, cbind(X, y = y), y = "y")
imp = FeatureImp$new(pred, loss = "mae")

pred2 = Predictor$new(mod, cbind(X2, y = y2), y = "y")
imp2 = FeatureImp$new(pred2, loss = "mae")

imp$results$dat.type = "Training data"
imp2$results$dat.type = "Test data"

imp.dat = rbind(imp$results, imp2$results)

ggplot(imp.dat) + geom_boxplot(aes(x = dat.type, y = importance)) + 
  scale_y_continuous("Feature importance of all features") + 
  scale_x_discrete("")
```

<!--
It is unclear to me which of the two results is more desirable.
So I will try to make a case for both versions and let you decide for yourself.
-->
2つの結果のどちらが望ましいかは明確ではありません。
そこで、双方のケースそれぞれについて述べてみますので、どちらがいいのかあなた自身で考えてみてください。

<!--**The case for test data**-->
**テストデータのケース**

<!--
This is a simple case: 
Model error estimates based on training data are garbage -> feature importance relies on model error estimates -> feature importance based on training data is garbage.  
Really, it is one of the first things you learn in machine learning:
If you measure the model error (or performance) on the same data on which the model was trained, the measurement is usually too optimistic, which means that the model seems to work much better than it does in reality.
And since the permutation feature importance relies on measurements of the model error, we should use unseen test data.
The feature importance based on training data makes us mistakenly believe that features are important for the predictions, when in reality the model was just overfitting and the features were not important at all.
-->
こちらについては単純です。
学習データに基づくモデル誤差の推定値は役に立たないということから、特徴量の重要度はモデル誤差の推定値に基づいているため、学習データに基づく特徴量重要度は役に立たないと言えます。
これは機械学習において一番最初に学ぶことですが、モデルを学習したときと同じデータでモデル誤差（もしくは性能）を測ると、それは常に楽観的すぎるものになり、実際よりもモデルの性能がよく思えてしまいます。
したがって、permutation feature importance はモデル誤差に基づいているので、まだ見ぬテストデータを用いるべきと言えます。
学習データに基づく特徴量重要度では、実際にはモデルがただ過学習しているだけで全く重要でない特徴量にもかかわらず、予測に重要であるという誤解が生まれてしまいます。

<!--**The case for training data**-->
**学習データのケース**

```{r garbage-svm-mvp}
max.imp = imp$results[imp$results$importance == max(imp$results$importance),]
```

<!--
The arguments for using training data are somewhat more difficult to formulate, but are IMHO just as compelling as the arguments for using test data.
We take another look at our garbage SVM.
Based on the training data, the most important feature was `r max.imp$feature`.
Let us look at a partial dependence plot of feature `r max.imp$feature`.
The partial dependence plot shows how the model output changes based on changes of the feature and does not rely on the generalization error.
It does not matter whether the PDP is computed with training or test data.
-->
学習データを使用することに関する議論は形式化するのが難しいですが、私見ではテストデータに関する議論と同じくらい説得力があるように思えます。
違う観点からこの役に立たない SVM についてみていきましょう。
学習データによると、重要な特徴量は `r max.imp$feature` でした。
`r max.imp$feature` についての Partial Dependence Plot (PDP) について見ていきましょう。
PDP により、モデルの出力が特徴量の違いによってどのように変わるのかを見ることができ、これは汎化誤差に依存しません。
PDP では、学習データかテストデータかは問題ではないのです。

<!--
fig.cap=sprintf("PDP of feature %s, which is the most important feature according to the feature importance based on the training data. The plot shows how the SVM depends on this feature to make predictions", max.imp$feature)
-->

```{r garbage-svm-pdp, fig.cap=sprintf("学習データに基づく最も重要な特徴量 %s に関するPDP。このプロットによって、SVMが予測をする際にどのようにこの特徴量を用いているかが示されています。", max.imp$feature)}
pdp = FeatureEffect$new(pred2, max.imp$feature, method = "pdp")
pdp$plot()
```

<!--
The plot clearly shows that the SVM has learned to rely on feature `r max.imp$feature` for its predictions, but according to the feature importance based on the test data (`r round(imp2$results[imp2$results$feature == max.imp$feature, "importance"], 2)`), it is not important.
Based on the training data, the importance is `r round(max.imp$importance, 2)`, reflecting that the model has learned to use this feature.
Feature importance based on the training data tells us which features are important for the model in the sense that it depends on them for making predictions.
-->
このプロットによると明らかに SVM は特徴量`r max.imp$feature` に依存して学習されていますが、テストデータに基づく特徴量重要度 (`r round(imp2$results[imp2$results$feature == max.imp$feature, "importance"], 2)`) によると、この特徴量は重要ではありません。
学習データに基づく重要度は`r round(max.imp$importance, 2)`であり、これはモデルがこの特徴量を用いるように学習されたことを示しています。
学習データに基づいた特徴量重要度は、予測をする際にそれらに依存しているという意味で、モデルにとって重要な特徴量はどれかを教えてくれます。

<!--
As part of the case for using training data, I would like to introduce an argument against test data.
In practice, you want to use all your data to train your model to get the best possible model in the end.
This means no unused test data is left to compute the feature importance.
You have the same problem when you want to estimate the generalization error of your model.
If you would use (nested) cross-validation for the feature importance estimation, you would have the problem that the feature importance is not calculated on the final model with all the data, but on models with subsets of the data that might behave differently.
-->
学習データを用いるケースの一環として、テストデータを使用することに対する反論を紹介したいと思います。
実際、最終的に可能な限り最良なモデルを得るために、すべてのデータを学習に使いたいと思うでしょう。
これは、特徴量重要度を計算するための未使用のテストデータが残されていないことを意味します。
モデルの汎化誤差を推定するときも同じような問題に直面します。
特徴量重要度を推定するために（ネストされた）交差検証を用いる場合、すべてのデータを学習に用いた最終的なモデルでは特徴量重要度が計算できず、一方でデータの一部を使ったモデルでは異なる振る舞いをしてしまうかもしれない、といった問題に直面するでしょう。

<!--
In the end, you need to decide whether you want to know how much the model relies on each feature for making predictions (-> training data) or how much the feature contributes to the performance of the model on unseen data (-> test data).
To the best of my knowledge, there is no research addressing the question of training vs. test data.
It will require more thorough examination than my "garbage-SVM" example.
We need more research and more experience with these tools to gain a better understanding.
-->
結局、モデルの予測がどの特徴量に頼っているのか（→学習データに基づく特徴量重要度）、もしくはどの特徴量がまだ見ぬデータに対するモデルの性能に寄与しているのか（→テストデータに基づく特徴量重要度）、どちらを知りたいのか決める必要があります。
私の知る限りでは、学習データとテストデータの疑問に関する研究はありません。
「役立たずの SVM」の例よりも徹底的な調査が必要でしょう。
より良い理解を得るためには、これらのツールについてより多くの研究と経験が必要になってくるでしょう。

<!--
Next, we will look at some examples.
I based the importance computation on the training data, because I had to choose one and using the training data needed a few lines less code.
-->
次に、例をいくつか見ていきましょう。
重要度の計算は、どちらか1つを選ばなければならず、必要となるコードが少なくて済むので、学習データに基づいています。

<!--### Example and Interpretation-->
### 例と解釈

<!--
I show examples for classification and regression. 
-->
分類と回帰の例を示します。

<!--**Cervical cancer (classification)**-->
**子宮頸がん（分類）**

<!--
We fit a random forest model to predict [cervical cancer](#cervical).
We measure the error increase by 1-AUC (1 minus the area under the ROC curve).
Features associated with a model error increase by a factor of 1 (= no change) were not important for predicting cervical cancer.
-->
[子宮頸がん](#cervical)を予測するためにランダムフォレストモデルを学習します。
誤差の増加を 1-AUC（1からROC曲線下面積を引いた値）で測定します。
並べ替えるとモデル誤差が 1 倍に増加する（＝変化なし）特徴量は、子宮頸がんの予測には重要ではありません。

```{r}
library('mlr')
library('iml')
data("cervical")
task = makeClassifTask(data = cervical, target = "Biopsy", positive = "Cancer")
learner = makeLearner('classif.randomForest', predict.type = 'prob')
mod = mlr::train(learner, task)
predictor = Predictor$new(mod, data = cervical[-which(names(cervical) == "Biopsy")], y = (cervical$Biopsy == "Cancer"), class = "Cancer")
auc_error = function(actual, predicted) 1 - Metrics::auc(actual, predicted)
importance = FeatureImp$new(predictor, loss = auc_error)
imp.dat = data.frame(importance$results[c("feature", "permutation.error", "importance")])
most_imp = imp.dat$feature[imp.dat$importance == max(imp.dat$importance)]
```

<!--
fig.cap = sprintf("The importance of each of the features for predicting cervical cancer with a random forest. The most important feature was %s. Permuting %s resulted in an increase in 1-AUC by a factor of %.2f", most_imp, most_imp, max(imp.dat$importance))
-->

```{r importance-cervical, fig.cap = sprintf("ランダムフォレストを用いて子宮頸がんを予測するための特徴量重要度。最も重要な特徴量は %s で、1-AUCは %.2f 倍に増加した。", most_imp, max(imp.dat$importance))}
plot(importance) +
  scale_x_continuous("Feature importance (loss: 1 - AUC)") +
   scale_y_discrete("")
```

<!--
The feature with the highest importance was `r imp.dat[1, 'feature']` associated with an error increase of `r round(imp.dat[1,'importance'], 2)` after permutation.
-->
最も重要度の高い特徴量は `r imp.dat[1, 'feature']` であり、誤差は `r round(imp.dat[1,'importance'], 2)` 増加することがわかりました。

<!--**Bike sharing (regression)**-->

**レンタル自転車（回帰）**

<!--
We fit a support vector machine model to predict [the number of rented bikes](#bike-data), given weather conditions and calendar information.
As error measurement we use the mean absolute error.
-->
SVM を用いて、気象条件とカレンダーの情報が与えられたときの[レンタル自転車の台数](#bike-data)を予測します。
誤差の測定には平均絶対誤差を使用します。

```{r}
data("bike")
task = makeRegrTask(data = bike, target = "cnt")
learner = makeLearner('regr.svm')
mod = mlr::train(learner, task)
predictor = Predictor$new(mod, data = bike[-which(names(bike) == "cnt")], y = bike$cnt)
importance = FeatureImp$new(predictor, loss = 'mae')
imp.dat = importance$results
best = which(imp.dat$importance == max(imp.dat$importance))
worst = which(imp.dat$importance == min(imp.dat$importance)) 
```

<!--
fig.cap = sprintf("The importance for each of the features in predicting bike counts with a support vector machine. The most important feature was %s, the least important was %s.", imp.dat$feature[best], imp.dat$feature[worst])
-->
```{r importance-bike, fig.cap = sprintf("SVM を用いた自転車レンタル台数を予測したときの各特徴量の重要度。最も重要な特徴量は %s で、最も重要でない特徴量は %s でした。", imp.dat$feature[best], imp.dat$feature[worst])}
plot(importance) +
   scale_y_discrete("")
```

<!--### Advantages-->
### 利点

<!--
**Nice interpretation**: Feature importance is the increase in model error when the feature's information is destroyed.
-->

特徴量重要度が高いということは、特徴量の情報が破壊されたときにモデル誤差が増加するという **すばらしい解釈** が可能です。

<!--
Feature importance provides a **highly compressed, global insight** into the model's behavior. 
-->
特徴量重要度は、モデルの振る舞いについて **高度に圧縮されたグローバルな洞察** を提供します。

<!--
A positive aspect of using the error ratio instead of the error difference is that the feature importance measurements are **comparable across different problems**. 
-->
誤差の差分の代わりに誤差の比を使用することの良い側面は、特徴量重要度の測定値が**異なる問題間で比較可能**であることです。

<!--
The importance measure automatically **takes into account all interactions** with other features.
By permuting the feature you also destroy the interaction effects with other features. 
This means that the permutation feature importance takes into account both the  main feature effect and the interaction effects on model performance.
This is also a disadvantage because the importance of the interaction between two features is included in the importance measurements of both features.
This means that the feature importances do not add up to the total drop in performance, but the sum is larger.
Only if there is no interaction between the features, as in a linear model, the importances add up approximately.
-->
重要度の計算は、自動的に他の特徴量との**すべての相互作用を考慮に入れます**。
特徴量を並べ替えることは、他の特徴量との相互作用の効果も破壊します。
これは、並べ替えた特徴量の重要度が，モデル性能における特徴量としての主効果と相互作用による効果の両方を考慮に入れることを意味します。
このことは、2つの特徴量間の相互作用の重要度が、両方の特徴量の重要度測定に含まれているため、欠点でもあります。
これは、特徴量重要度が性能の全体的な低下の合計ではなく、総和が大きくなってしまうことを意味します。
線形モデルのように特徴間の相互作用がない場合にのみ、重要度はほぼ総和になります。

<!--
Permutation feature importance **does not require retraining the model**.
Some other methods suggest deleting a feature, retraining the model and then comparing the model error.
Since the retraining of a machine learning model can take a long time, "only" permuting a feature can save a lot of time.
Importance methods that retrain the model with a subset of features appear intuitive at first glance, but the model with the reduced data is meaningless for the feature importance.
We are interested in the feature importance of a fixed model.
Retraining with a reduced dataset creates a different model than the one we are interested in.
Suppose you train a sparse linear model (with Lasso) with a fixed number of features with a non-zero weight.
The dataset has 100 features, you set the number of non-zero weights to 5.
You analyze the importance of one of the features that have a non-zero weight.
You remove the feature and retrain the model.
The model performance remains the same because another equally good feature gets a non-zero weight and your conclusion would be that the feature was not important.
Another example:
The model is a decision tree and we analyze the importance of the feature that was chosen as the first split.
You remove the feature and retrain the model. 
Since another feature is chosen as the first split, the whole tree can be very different, which means that we compare the error rates of (potentially) completely different trees to decide how important that feature is for one of the trees.
-->
Permutation feature importance は **モデルの再学習を必要としません**。
他の方法の中には，特徴量を削除してモデルを再学習し、モデル誤差を比較するものもあります。
機械学習モデルの再学習には長い時間がかかるので、特徴量を並べ替える "だけ" で済めば多くの時間を節約できます。
特徴量の一部でモデルを再学習する方法は一見すると直感的に見えますが、データを減らしたモデルでは特徴量重要度に意味がありません。
我々が知りたいのは、モデルを固定して得られる特徴量重要度なのです。
削減されたデータセットで再学習すると、我々が興味を持っているモデルとは異なるモデルが得られます。
例えば、スパースな線形モデル（Lassoを使用）を、使用する特徴量の数を固定して重みを学習したとします。
データセットには 100 個の特徴量があり、非ゼロの重みの数を 5 に設定します。
非ゼロの重みを持つ特徴量のうちの 1 つの重要度を分析します。
次に、その特徴量を削除してモデルを再学習します。
その結果、同じように良い特徴量に非ゼロの重みが与えら、モデルの性能が変わらなかったとすると、先ほどの特徴量は重要ではないという結論に至ります。
また、こんなことも起こり得ます。
モデルは決定木で、最初の分割として選ばれた特徴量の重要度を分析します。
その特徴量を削除してモデルを再学習します。
別の特徴量が最初の分割として選択されるので、木全体が全く異なったものになります。つまり、（潜在的に）全く異なる木の誤差率を比較して、その特徴量が元の木にとって、どれだけ重要かを決定することになってしまうのです。

<!--### Disadvantages-->

### 欠点
<!--
It is very **unclear whether you should use training or test data** to compute the feature importance.
-->
特徴量重要度を計算するために**学習データを用いるべきか、テストデータを用いるべきかは明らかではありません**。

<!--
Permutation feature importance is **linked to the error of the model**.
This is not inherently bad, but in some cases not what you need.
In some cases, you might prefer to know how much the model's output varies for a feature without considering what it means for performance.
For example, you want to find out how robust your model's output is when someone manipulates the features. 
In this case, you would not be interested in how much the model performance decreases when a feature is permuted, but how much of the model's output variance is explained by each feature. 
Model variance (explained by the features) and feature importance correlate strongly when the model generalizes well (i.e. it does not overfit).
-->
Permutation feature importance は **モデル誤差と関連しています **。
これは本質的に悪いことではありませんが、場合によっては我々が求めるものと異なります。
ある特徴量がモデルの性能に対しどういう意味を持つかを考えることなく、その特徴量によってモデルの出力がどう変わるかを知りたいケースもあります。
例えば、誰かによって特徴量が改ざんされた場合にモデルの出力がどの程度頑健か知りたい場合です。
この場合には、特徴量が並べ替えられた場合にどの程度モデルの性能が落ちるかではなく、モデルの出力の変化が各特徴量によってどの程度説明されるのかを知りたいはずです。
（特徴量によって説明される）モデルの出力変化と特徴量重要度は、モデルが良く汎化されている（つまり過学習していない）時には、強く相関します。

<!--
You **need access to the true outcome**. 
If someone only provides you with the model and unlabeled data -- but not the true outcome -- you cannot compute the permutation feature importance.
-->
**真の結果にアクセスできる必要があります**。
もしモデルとラベル付けされていないデータのみが与えられ、真の結果がなかったならば、並べ替えた特徴量の重要度は計算できません。

<!--
The permutation feature importance depends on shuffling the feature, which adds randomness to the measurement.
When the permutation is repeated, the **results might vary greatly**.
Repeating the permutation and averaging the importance measures over repetitions stabilizes the measure, but increases the time of computation.
-->
permutation feature importance は特徴量のシャッフルに依存しているため、推定結果にランダム性を持ちます。
何度も計算すると、結果が大きく変わるかもしれません。
重要度の測定値を繰り返し平均すれば、推定結果は安定しますが、計算にかかる時間は増大します。

<!--
If features are correlated, the permutation feature importance **can be biased by unrealistic data instances**. 
The problem is the same as with [partial dependence plots](#pdp):
The permutation of features produces unlikely data instances when two or more features are correlated.
When they are positively correlated (like height and weight of a person) and I shuffle one of the features, I create new instances that are unlikely or even physically impossible (2 meter person weighing 30 kg for example), yet I use these new instances to measure the importance.
In other words, for the permutation feature importance of a correlated feature, we consider how much the model performance decreases when we exchange the feature with values we would never observe in reality.
Check if the features are strongly correlated and be careful about the interpretation of the feature importance if they are.
-->
もし特徴量に相関があるのならば、permutation feature importance は現実的ではないインスタンスによって結果が歪められるかもしれません。
これは、[Partial Dependence Plots](#pdp) と同じ問題です。
2つ以上の特徴量に相関がある場合、特徴量の並べ替えを行うことで、起こりえないデータを作り出してしまいます。
（人間の体重と身長のように）正の相関があり、その1つをシャッフルするとき、ありえないインスタンス（例えば身長 2m, 体重 30kg）を作り出してしまいますが、そのようなインスタンスも特徴量重要度の計算に使用されてしまいます。
言い換えれば、他の特徴量と相関のある場合の permutation feature importance は、特徴量の入れ替えによって得られた現実に観測しえないようなデータに対してモデルの性能がどの程度落ちたかについて考えていると言えます。
特徴量が強く相関しているかどうかをチェックし、相関がある場合は、特徴量重要度の解釈に注意するようにしましょう。

<!--
Another tricky thing:
**Adding a correlated feature can decrease the importance of the associated feature** by splitting the importance between both features.
Let me give you an example of what I mean by "splitting" feature importance:
We want to predict the probability of rain and use the temperature at 8:00 AM of the day before as a feature along with other uncorrelated features.
I train a random forest and it turns out that the temperature is the most important feature and all is well and I sleep well the next night.
Now imagine another scenario in which I additionally include the temperature at 9:00 AM as a feature that is strongly correlated with the temperature at 8:00 AM.
The temperature at 9:00 AM does not give me much additional information if I already know the temperature at 8:00 AM.
But having more features is always good, right?
I train a random forest with the two temperature features and the uncorrelated features.
Some of the trees in the random forest pick up the 8:00 AM temperature, others the 9:00 AM temperature, again others both and again others none. 
The two temperature features together have a bit more importance than the single temperature feature before, but instead of being at the top of the list of important features, each temperature is now somewhere in the middle.
By introducing a correlated feature, I kicked the most important feature from the top of the importance ladder to mediocrity.
On one hand this is fine, because it simply reflects the behavior of the underlying machine learning model, here the random forest. 
The 8:00 AM temperature has simply become less important because the model can now rely on the 9:00 AM measurement as well.
On the other hand, it makes the interpretation of the feature importance considerably more difficult.
Imagine you want to check the features for measurement errors.
The check is expensive and you decide to check only the top 3 of the most important features.
In the first case you would check the temperature, in the second case you would not include any temperature feature just because they now share the importance.
Even though the importance values might make sense at the level of model behavior, it is confusing if you have correlated features.
-->
もう1つ、トリッキーなことがあります。
**相関した特徴量を追加すると**、両方の特徴量の間で重要度を分割することで、**関連する特徴量の重要度が低下する**、ということが起こり得ます。
特徴量重要度を「分割する」とはどういうことか、例を挙げてみましょう。
他の相関のない特徴量とともに前日の午前8時の気温を特徴量として使用し、降水確率を予測します。
ランダムフォレストで学習し、気温が最も重要な特徴量だとわかり、うまくいったので夜はよく眠れました。
では、午前8時の気温と強く相関するような午前9時の気温を追加したときを想像してみましょう。
午前8時の気温をすでに知っていたならば、午前9時の気温はそれほど多くの情報を与えません。
でも、特徴量はたくさんあるほうが良いはずです。
ランダムフォレストを2つの気温の特徴量と、他の相関のない特徴量から学習しました。
ランダムフォレストの個々の木は午前8時の気温を選んだり、午前9時の気温を選んだり、あるいは両方選んだりどちらも選ばなかったりしました。
2つの気温の特徴量のどちらもは、1つだけで学習したときよりも少しだけ重要度が高くなっていますが、特徴量を重要な順にリストかすると、どちらの気温も真ん中ぐらいの順位となっていました。
相関する特徴量を入れることによって、最も重要な特徴量をトップから平凡なものへと蹴り落してしまいました。
ある意味では、これは単に機械学習モデル（ここではランダムフォレスト）の動作を反映しているだけなので、問題ありません。
モデルが午前9時の気温にも頼ることができるようになったので、単純に午前8時の気温の重要度が低くなっただけです。
一方で、これによって特徴量重要度の解釈がかなり難しいものになってしまいます。
計測誤差について特徴量をチェックすることを想像してみてください。
チェックは大変なので、重要な特徴量を上位3つだけチェックすることに決めたとしましょう。
最初のケース(午前8時の気温のみ)では、最も重要な特徴量である気温をチェックしますが、2つ目のケース(午前9時の気温も含む) では、重要度がシェアされてしまっているので重要度の上位3つに気温の特徴量は1つも含まれません。
相関のある特徴量がある場合、重要度の値はモデルの動作レベルでは理解しうるものであったとしても、混乱を招く恐れがあります。

<!--### Software and Alternatives-->
### ソフトウェアと代替手法

<!--
The `iml` R package was used for the examples.
The R packages `DALEX` and `vip`, as well as the Python library `alibi`, also implement model-agnostic permutation feature importance.
-->

例では、R パッケージの `iml` を用いました。
R パッケージ `DALEX` や `vip`、Pythonライブラリ `alibi` もまた、モデルに依存しない、permutation feature importance の実装があります。

<!--
An algorithm called [PIMP](https://academic.oup.com/bioinformatics/article/26/10/1340/193348) adapts the feature importance algorithm to provide p-values for the importances.
-->

[PIMP](https://academic.oup.com/bioinformatics/article/26/10/1340/193348) と呼ばれるアルゴリズムは、重要度の p値 を提供するために、特徴量重要度アルゴリズムを改良しています。

[^Breiman2001]: Breiman, Leo.“Random Forests.” Machine Learning 45 (1). Springer: 5-32 (2001).

[^Fisher2018]: Fisher, Aaron, Cynthia Rudin, and Francesca Dominici. “Model Class Reliance: Variable importance measures for any machine learning model class, from the ‘Rashomon’ perspective.” http://arxiv.org/abs/1801.01489 (2018).

